## Artifact Registryにpushする際のimageについて

以下のような形式で記述する。

```
${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-memo/image:${{ github.sha }}-${{ github.run_attempt }}
```

この際、REGIONに`asia-northeast1-a`を指定すると以下のエラーになる。

```
Error: buildx failed with: ERROR: error parsing HTTP 404 response body: invalid character '<' looking for beginning of value:
```

これは、`asia-northeast1-a`が使えない（Artifact Registryが利用可能なLocationとして存在しない）ために出るエラー。

利用可能なロケーションは以下の中から選択する。

https://cloud.google.com/artifact-registry/docs/repositories/repo-locations?hl=ja

この場合だと、`asia-northeast1`に変えると動く。

## GitHub Actions からのキーなしの認証の有効化（Workload Identityを用いた認証）

TODO: 記事にしたい。GitHub Actions からのGoogle Cloudへのキーなし認証を理解するまでの道のり
TODO: 腹落ちして完全に理解する。理解に時間をかける

### 概要
- これまではGitHub ActionsからGoogle CloudのArtifact Registryなどに認証する際にService Account Keyの発行が必要であった
- しかし、これは管理が複雑になるだけでなく、キーの漏洩リスクも孕んでいる
- そこで利用するのが、Workload Identity 連携（外部ワークロードのIDをGCPと連携する機能）を使用した GitHub Actions から Google Cloud への認証
- これは、GitHub が GitHub Actions ワークフローに OIDC トークンを導入したためできるようになった

### GitHub Actions からのキーなしの認証の流れ

処理の流れは以下の通り。

1. GitHub Actions上でGitHub OIDCトークン発行サーバー（OIDC Provider）からGitHub OIDCトークンを発行
2. GitHub ActionsがOIDCトークンをGoogle CloudのSTS API（Security Token Service API）に渡す
3. STS APIはOIDCトークンの正当性をWorkload Identity Poolに登録した情報を使ってチェック
- Workload Identity PoolはOIDCトークンの管理を行う
- Workload Identity Providerをまとまるための論理的な入れ物です。ファイルシステムにおけるディレクトにみたいなもの
- Workload Identity ProviderはWorkload Identity Poolと外部IDプロバイダとの関係を表すエンティティ
- Workload Identity Poolで管理するOIDCトークンのプロバイダを指定・制限する（ex. GitHubだと認証を特定のリポジトリに制限するなど）
- gcloudコマンドだと以下のように設定できる
```shell
gcloud iam workload-identity-pools providers create-oidc PROVIDER_ID \
    --location="global" \
    --workload-identity-pool="POOL_ID" \
    --issuer-uri="ISSUER" \
    --allowed-audiences="AUDIENCE" \
    --attribute-mapping="MAPPINGS" \
    --attribute-condition="CONDITIONS"
```
4. OIDCトークンがWorkload Identity PoolのPool Providerの設定に合致していればSTSトークンを発行する
- Workload Identity Poolに対してService Accountを紐付けておく必要がある
```shell
gcloud iam service-accounts add-iam-policy-binding "my-service-account@${PROJECT_ID}.iam.gserviceaccount.com" \
  --project="${PROJECT_ID}" \
  --role="roles/iam.workloadIdentityUser" \
  --member="principalSet://iam.googleapis.com/${WORKLOAD_IDENTITY_POOL_ID}/attribute.repository/${REPO}"
```
5. STSトークンを使ってService Account Credentials APIを叩き、リソースへの権限を持つサービスアカウントのIDトークン（サービスアカウントに成りすますことができる一時トークン）を入手する
- リソースへの操作権限を持つサービスアカウントは事前に発行しておく必要がある
- サービスアカウントの作成は以下のように行う
```shell
gcloud iam service-accounts create "${SERVICE_ACCOUNT_NAME}" \
  --project "${PROJECT_ID}"
```
```shell
# 権限の付与
gcloud projects add-iam-policy-binding "${PROJECT_ID}" \
  --role="roles/iam.serviceAccountUser" \
  --member="serviceAccount:${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
```
6. GitHub Actionsのワークロードから発行したサービスアカウントのIDトークンでリソースを操作する（Artifact RegistryへのアクセスやCloud Runのデプロイなど）

参考: https://christina04.hatenablog.com/entry/workload-identity-federation

### GitHub ActionsからWorkload Identityを用いたキーなし認証をする手順

[GitHub Actions で OIDC を使用して GCP 認証を行う](https://zenn.dev/kou_pg_0131/articles/gh-actions-oidc-gcp)

### GitHub ActionsからCloud Runにデプロイする場合について

以下のようなエラー。

```
ERROR: (gcloud.beta.run.jobs.update) PERMISSION_DENIED: Permission 'iam.serviceaccounts.actAs' denied on service account hoge-db-migration@prj-hoge-fuga123.iam.gserviceaccount.com (or it may not exist).
```

「Cloud Runのデプロイの順序」は細かく分解すると以下のようになっている。

1. Github ActionsからGoogle CloudのサービスアカウントにOIDC（例えばa-github-actions@prj-hoge-p-8ad8.iam.gserviceaccount.com）
2. OIDC先のサービスアカウントでCloud Runのランタイムサービスアカウトになりすます（iam.serviceaccounts.actAs）（例えばhoge@prj-fuga-s-194f.iam.gserviceaccount.com）
3. Cloud Runをデプロイ

今回のケースだと「2」でOIDCアカウントがCloud Runのサービスアカウントになりすまそうとしてアカウントが存在しなかったためエラーになった。

もっと詳しく↓

- Cloud Run のすべてのリビジョンはサービス アカウントにリンクされている
- このサービス アカウントは、Google Cloud APIs での認証を行うために Google Cloud クライアント ライブラリによって自動的に使用される
  - Cloud RunからCloud Storage、Firestore、Cloud SQL、Pub/Sub、Cloud Tasksなどにアクセスするため
- サービス アカウントの指定がない場合、Cloud Run はすべての Google Cloud APIs に対して幅広い権限を持つデフォルトのサービス アカウントにリビジョンまたはジョブをリンクする
  - Compute Engine のデフォルト サービス アカウントになっている
- デフォルトのサービス アカウントが便利な場合もあるが、きめ細かい権限を持つ独自のユーザー管理サービス アカウントを作成し、そのサービス アカウントを Cloud Run サービスまたはジョブの ID として割り当てることが推奨されている
- Cloud Runのデプロイ時にユーザーが管理するサービス アカウントを割り当てるためには、デプロイ時に使用するサービスアカウントがそのサービス アカウントの権限を借用できる権限（`iam.serviceAccounts.actAs`）を持っている必要がある
  - GitHub Actions上でWorkload Identity連携している`a-github-actions@prj-hoge-p-8ad8.iam.gserviceaccount.com`を使ってCloud Runにデプロイし、そのときにCloud Runに対してユーザー定義のサービスアカウントである`hoge@prj-fuga-s-194f.iam.gserviceaccount.com`を割り当てたい場合、`a-github-actions@prj-hoge-p-8ad8.iam.gserviceaccount.com`は`iam.serviceAccounts.actAs`を持っている必要があるということ
  - `hoge@prj-fuga-s-194f.iam.gserviceaccount.com`はservice.ymlの`serviceAccountName`に定義されている想定
- この権限は、`roles/iam.serviceAccountUser` IAM ロールを介して付与できる
- つまり、Cloud Runにユーザーの管理するサービスアカウント(CloudRunのデフォルトで実行されるサービスアカウントは権限が強すぎるので最小にしようとすると自然と必要になる)を割り当てるのにも権限 (`iam.serviceAccounts.actAs`)が必要だよという話

参考: https://cloud.google.com/run/docs/securing/service-identity?hl=ja

以下の記事とかも、これが原因で出たエラー。

https://qiita.com/MAKOTO1995/items/130a87e485b1d275fa04

### 疑問点

1. なぜ`Direct Workload Identity Federation`を使わない？
- https://github.com/google-github-actions/auth?tab=readme-ov-file
-> これ？
-> To generate OAuth 2.0 access tokens or ID tokens, you must provide a service account email, and the Workload Identity Pool must have roles/iam.workloadIdentityUser permissions on the target Google Cloud Service Account. Follow the steps for Workload Identity Federation through a Service Account instead.
-> OAuth 2.0 アクセストークンまたは ID トークンを生成するには、サービスアカウントの電子メールを提供し、ワークロード ID プールが対象の Google クラウドサービスアカウントの roles/iam.workloadIdentityUser 権限を持っている必要があります。代わりに、サービスアカウントを介したワークロード ID フェデレーションの手順に従ってください。
2. 

### 参考資料

- [GitHub ActionsとGoogle CloudのOIDCの仕組みを理解する](https://zenn.dev/takamin55/articles/53d732b081ba66)
    - 分かりやすい..!
- [GitHub Actions からのキーなしの認証の有効化](https://cloud.google.com/blog/ja/products/identity-security/enabling-keyless-authentication-from-github-actions)
- [GitHub Actions: Secure cloud deployments with OpenID Connect](https://github.blog/changelog/2021-10-27-github-actions-secure-cloud-deployments-with-openid-connect/)
- [GitHub ActionsでWorkload Identityでの認証を入れてGoogle CloudのAPIを叩く](https://zenn.dev/satohjohn/articles/1645be8e83eab6)
- [GitHub Actions で OIDC を使用して GCP 認証を行う](https://zenn.dev/kou_pg_0131/articles/gh-actions-oidc-gcp)
    - 今回はこれを参考にした
- [Google Cloud の Workload Identity 連携でGitHub Actionsから認証する](https://blog.lacolaco.net/posts/github-actions-oidc-google-cloud/)
- [GitHub Actions の OpenID Connect サポートについて](https://zenn.dev/miyajan/articles/github-actions-support-openid-connect)
- [Workload Identity Federationを図で理解する](https://christina04.hatenablog.com/entry/workload-identity-federation)
    - めちゃ分かりやすい
- [サービスアカウントキーを用いずにGitHub ActionsからGoogle Cloudと認証する](https://dev.classmethod.jp/articles/google-cloud-auth-with-workload-identity/)
    - これも分かりやすい
- [Google Cloud Platform での OpenID Connect の構成](https://docs.github.com/ja/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform)
- [Google Cloud Storage で GitHub Actions を有効にする](https://docs.github.com/ja/enterprise-server@3.12/admin/github-actions/enabling-github-actions-for-github-enterprise-server/enabling-github-actions-with-google-cloud-storage)
- [Workload Identityを使ってJSONキーなしでGitHubActionsからGCPにアクセスする](https://qiita.com/shiozaki/items/9d50f28d38f027c6beb3)
