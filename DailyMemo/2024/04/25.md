## 意味のないアウトプットをやめる７つの方法

1. 第三者に見てもらう
2. 自分の言葉で語る
3. 図にまとめる
4. 途中経過でも発信する
5. 毎日続ける
6. 当たり前を当たり前と思わない
7. 目的意識を持つ

https://paiza.hatenablog.com/entry/2024/04/14/090641

## コンテナイメージ使うならdistrolessもいいよねという話

- distroless imageとは？
    - distrolessは、Googleが提供している必要最小限の依存のみが含まれるDebian10(buster)を基に作成されたコンテナイメージ
    - imageのサイズが本当に小さく、aptやshellさえも含まれていない
- 何が嬉しいのか
    - セキュア
        - 本当に実行に必要なのファイルのみを含んだimageとなっているので、不要なバグや脆弱性を埋め込みにくい
    - 軽量
        - 含まれるファイルを最小限にしているので、imageのサイズを小さくできる

参考: https://zenn.dev/yoshii0110/articles/21ddb58c6f6bfa

## SQL内のクエリ内で limit するか。それとも取った後に limit するか

- DB 件数多い場合はクエリで limit した方が良さそう
    - DBの取得件数が増えてしまうので
    - メモリ使いそう
- 少ないならどちらでも？
- でも、DBのデータは増えるかもしれないし、基本的にはクエリの時点でlimitした方が良さそう

## DB と直接接続か、抽象化層の API を挟むか、メリデメなど

以下のどちらにするかという話。

1. client -> REST API -> DB
2. client -> REST API -> 抽象化 API -> DB

- DB と直接接続
  - メリット
    - 抽象化 API が落ちても REST API に影響しない
  - デメリット
    - DB のパスワード管理が必要
    - DB のスキーマ変更があった場合に修正対応が必要（DB のスキーマ変更に弱い）
- 抽象化 API と接続
  - メリット
    - 抽象化 API という抽象化層を挟んでいるので、DB のスキーマ変更があった場合に修正が不要
    - データソースが単一になる（Single Source of Truth）
      - セキュリティ面でも安心
    - 抽象化 API のみを参照すればいい（複数の DB と接続する必要がない）ので実装もシンプルになりそう
    - DB データの加工処理やデータの取得ロジックが複数アプリで分散するのを防げる
      - ex. あるデータの加工処理に変更があった場合も 抽象化 API のみを変更すれば良い
  - デメリット
    - 抽象化 API が落ちたら REST API も落ちる
    - 接続アプリ数が増えるのでレイテンシが悪化する可能性がある

## Cloud Runがスケールする条件について

受信リクエスト、イベント、CPU 使用率のレートに加えて、スケジュールされるインスタンスの数は次の要因の影響を受けます。

- 既存インスタンスの 1 分間の CPU 使用率（スケジュールされたインスタンスの CPU 使用率を 60% に維持するため）。
- 1 分間でのリクエストの最大同時実行数と比較した現在の同時実行数。
- インスタンスの最大数の設定
- インスタンスの最小数の設定

Cloud Run のオートスケーラーは 5 秒ごとにこれらを評価します。

参考: https://cloud.google.com/run/docs/about-instance-autoscaling?hl=ja