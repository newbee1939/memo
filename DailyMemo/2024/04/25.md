## 意味のないアウトプットをやめる７つの方法

1. 第三者に見てもらう
2. 自分の言葉で語る
3. 図にまとめる
4. 途中経過でも発信する
5. 毎日続ける
6. 当たり前を当たり前と思わない
7. 目的意識を持つ

https://paiza.hatenablog.com/entry/2024/04/14/090641

## コンテナイメージ使うならdistrolessもいいよねという話

- distroless imageとは？
    - distrolessは、Googleが提供している必要最小限の依存のみが含まれるDebian10(buster)を基に作成されたコンテナイメージ
    - imageのサイズが本当に小さく、aptやshellさえも含まれていない
- 何が嬉しいのか
    - セキュア
        - 本当に実行に必要なのファイルのみを含んだimageとなっているので、不要なバグや脆弱性を埋め込みにくい
    - 軽量
        - 含まれるファイルを最小限にしているので、imageのサイズを小さくできる

参考: https://zenn.dev/yoshii0110/articles/21ddb58c6f6bfa

## SQL内のクエリ内で limit するか。それとも取った後に limit するか

- DB 件数多い場合はクエリで limit した方が良さそう
    - DBの取得件数が増えてしまうので
    - メモリ使いそう
- 少ないならどちらでも？
- でも、DBのデータは増えるかもしれないし、基本的にはクエリの時点でlimitした方が良さそう

## DB と直接接続か、抽象化層の API を挟むか、メリデメなど

以下のどちらにするかという話。

1. client -> REST API -> DB
2. client -> REST API -> 抽象化 API -> DB

- DB と直接接続
  - メリット
    - 抽象化 API が落ちても REST API に影響しない
  - デメリット
    - DB のパスワード管理が必要
    - DB のスキーマ変更があった場合に修正対応が必要（DB のスキーマ変更に弱い）
- 抽象化 API と接続
  - メリット
    - 抽象化 API という抽象化層を挟んでいるので、DB のスキーマ変更があった場合に修正が不要
    - データソースが単一になる（Single Source of Truth）
      - セキュリティ面でも安心
    - 抽象化 API のみを参照すればいい（複数の DB と接続する必要がない）ので実装もシンプルになりそう
    - DB データの加工処理やデータの取得ロジックが複数アプリで分散するのを防げる
      - ex. あるデータの加工処理に変更があった場合も 抽象化 API のみを変更すれば良い
  - デメリット
    - 抽象化 API が落ちたら REST API も落ちる
    - 接続アプリ数が増えるのでレイテンシが悪化する可能性がある

## Cloud Runがスケールする条件について

受信リクエスト、イベント、CPU 使用率のレートに加えて、スケジュールされるインスタンスの数は次の要因の影響を受けます。

- 既存インスタンスの 1 分間の CPU 使用率（スケジュールされたインスタンスの CPU 使用率を 60% に維持するため）。
- 1 分間でのリクエストの最大同時実行数と比較した現在の同時実行数。
- インスタンスの最大数の設定
- インスタンスの最小数の設定

Cloud Run のオートスケーラーは 5 秒ごとにこれらを評価します。

メモリ使用率は見ない？

参考: https://cloud.google.com/run/docs/about-instance-autoscaling?hl=ja

## Cloud Run: containerConcurrency（インスタンスあたりの最大同時リクエスト数）

### 概要

- インスタンスあたりの最大同時リクエスト数
- Cloud Run サービスでは、リビジョンのスケーリングが自動的に行われる
- すべての受信リクエストを処理できるように、必要なインスタンスの数が調整される
- リクエストを処理する`インスタンスが増えると、CPU とメモリの消費量も増加し、コストも高くなる`
- より細かく制御するために、Cloud Run では、インスタンスあたりの最大同時リクエスト数を設定し、1 つのインスタンスで同時に処理可能な最大リクエスト数を指定できる

### インスタンスあたりの最大同時リクエスト数

- デフォルトでは、各 Cloud Run インスタンスは同時に最大 80 件のリクエストを受信できる
- 1,000 件まで増やすことができる
- デフォルト値を使用する必要があるが、必要に応じて最大同時実行数を減らすこともできる
- たとえば、コードで並行リクエストを処理できない場合は、`同時実行を 1` に設定する
  - `1コンテナインスタンスが同時に処理するリクエストの数は最大1`になる
  - `他のリクエストを捌くため、別のコンテナインスタンスが立ち上がる`
  - ex. 同時に3リクエストが来た場合、最大同時リクエスト数が3　の場合は一つのコンテナインスタンスで3リクエストを受けるが、最大同時リクエスト数が1の場合は3つのコンテナインスタンスが立ち上がって、それぞれが一つのリクエストを処理する
- 指定された同時実行の値は最大値であり、インスタンスの CPU の使用率がすでに高い場合、Cloud Run は特定のインスタンスにそれほど多くのリクエストを送信しない

参考: https://cloud.google.com/run/docs/configuring/concurrency?hl=ja
参考: https://cloud.google.com/run/docs/about-concurrency?hl=ja
