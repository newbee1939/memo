## ATDD

- ATDD=`Acceptance Test Driven Development`
- ATDD は、受け入れテストを最初にテストケースとして書いておき、内部プロセスで TDD を行うアプローチ

https://www.qbook.jp/column/1463.html

## Gherkin(ガーキン)記法

- テスト記述の記法
- Gherkin 記法とはシナリオ記述フォーマットの 1 つで、`こういう状態のとき、こういう動作を行えば、こうなることが期待される`という形式でシナリオを記述する
- Jestでspecのテストを書くときに参考になりそう

参考: [Gherkin 記法はじめました](https://zenn.dev/jyoppomu/articles/4bd0ddfc75545b)

## jest.fn()について

```ts
reflector.get = jest.fn().mockReturnValue(["hoge"]);
```

- Jest テストフレームワークで使用される`モック関数を作成`するためのメソッド
- 関数の呼び出しを監視したり、戻り値を指定したり、特定の実装をモックしたりすることができる

## NestJS には複数のデコレータをまとめる為のヘルパーメソッドが用意されている

なるほど。。

参考: https://zenn.dev/kisihara_c/books/nest-officialdoc-jp/viewer/overview-customroutedecorators

```ts
import { applyDecorators } from "@nestjs/common";

export function Auth(...roles: Role[]) {
  return applyDecorators(
    SetMetadata("roles", roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: "Unauthorized" }),
  );
}
```

## CDN Interconnect について

- `Akamai と GCP の経路の最適化するためのオプション`
- `パフォーマンスを良くする`ための設定

## jest で例外が投げられたことをテスト

参考: https://jestjs.io/docs/expect#tothrowerror
参考: https://jestjs.io/docs/expect#rejects

`同期関数`の場合、以下のように記述する。

`expect 内にメソッドを定義しなくてはならない`点に注意。

```ts
test("throws on octopus", () => {
  expect(() => {
    drinkFlavor("octopus");
  }).toThrow();
});
```

## NestJS の Guards について

参考: https://docs.nestjs.com/guards

- ガードは`@Injectable()デコレーター`でアノテーションされたクラスで、`CanActivate` インターフェイスを実装している
  - この関数は、現在のリクエストが許可されているかどうかを示す boolean を返すべき
  - この関数は、同期または非同期（Promise または Observable 経由）でレスポンスを返すことができる
  - もし true を返せば、リクエストは処理される。false を返せば、Nest はリクエストを拒否する
- ガードは`一つの責任`を持つ
- `実行時に存在する特定の条件(パーミッション、ロール、ACL など)に応じて、与えられたリクエストがルートハンドラによって処理されるかどうかを決定`する
- これはしばしば`認可`と呼ばれる
- ガードはすべてのミドルウェアの後、インターセプターやパイプの前に実行される。
- `認可は Guard にとって素晴らしいユースケース`である
- なぜなら、`特定のルートは、呼び出し元（通常は特定の認証済みユーザー）が十分なパーミッションを持っている場合にのみ利用可能であるべき`だから
- 以下ようにコントローラに Guard を紐付けることができる

```ts
@Controller("cats")
@UseGuards(RolesGuard)
export class CatsController {}
```