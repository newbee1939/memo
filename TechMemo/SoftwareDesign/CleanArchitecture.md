## クリーンアーキテクチャ概要

- クリーンアーキテクチャとは、過去の多くのソフトウェア設計手法に共通していた、ある特徴を少々極端に表現した設計の例
- あの同心円の図は、あくまで象徴的な例であり、これが「クリーンアーキテクチャ」という名前を持つ定まった方法論ではないことに注意する
- コンセプトの要約は以下の通り
    - ソフトウェアの構造には意識の異なる複数の領域が存在する
    - 領域のレイヤー関係は常に、詳細から主題へと一定の方向に依存する

## 複雑な汚い設計はなぜ生産性を落とすか

- 単純にコードの「意味」を把握するのに時間がかかるから

## 汚い設計の特徴

- まとまりが悪くあちこちで変更しないといけないので苦労する
- 同じところに意味の違うものが混ざっていて壊れやすい

## クリーンアーキテクチャの目的

- 何をどう配置するか具体的に決まっている技術の使い方とは異なり、独自に開発するソフトウェアのアーキテクチャは人間の事情で変わってくる
- なので、各自がオリジナルで設計せざるを得ないのは宿命付けられている
- クリーンアーキテクチャの目的は、この多様な独自設計を最小労力で維持するコツを一般化すること
- 例えて言えば、`独自ソフトウェアのアーキテクチャを設計するためのフレームワーク`

## アーキテクチャは何の役に立つのか？

- 良いアーキテクチャは`ソフトウェアを開発するパフォーマンス`を向上させる

## クリーンアーキテクチャの歴史

- 2010年のWeb界隈ではRuby on RailsのようなMVCのフレームワーク・アーキテクチャが流行った
    - 出来合いの骨組みを元にコードを肉付けする
- この潮流に対して「ソフトウェアを設計するというのは、こんなやり方とは全く違うことだ」とRails以前のスタイルに改めて注目するトレンドを生み出したのが、クリーンアーキテクチャとその支持者たち
    - 原点回帰ってこと

## 依存の向きと安定度

- ソフトウェアのモジュールは必ず何かと繋がっている
    - 何とも繋がっていないモジュールはゴミ
- モジュール間には必ず「依存関係」が存在している
    - AはBに依存する=モジュールAがモジュールBを使う
    - AはBがないと成立しないが、BはAがなくても成立する

## 安定度とは？

- 単純に、頻繁に変わるものに依存しないのが、シンプルかつ合理的な指針
- 依存するものが変わりにくければ、その影響を受けて変更を強いられる可能性が減る
    - 影響範囲が減る
    - コードを変更しやすい（コードの柔軟性が上がる）
- コードの変わりにくさを「安定度」と呼ぶ
- 安定度の高いものに依存するのは、安定度の低いものに依存するより安心

## 綺麗な設計とは？

- 一つの関心が一つの箇所に閉じている
- 利用する/されるの関係箇所を可能な限り減らす
- できるだけ変更頻度の高い事情に依存しない
    - クリーンアーキテクチャはここに関係する
    - 安定度が高いものに依存するってこと

## クリーンアーキテクチャの円

- 1層目: ドメインモデル（エンティティ）
    - ユーザーがどんな操作をしたいかとは無関係に、普遍的に存在する本質を入れる
    - 誰がどんなコードを欲しているか以前に、どんなニーズであってもこれは必要、誰にとってもこれは操作対象だと言える、まるで現実から事実をただ写し取っただけのようなコードが存在する
    - そういったものだけ集めたものを「ドメインモデル」と呼ぶ
    - この領域は、プログラミング言語の文法と標準ライブラリ以外の何にも依存しないように記述する
    - この現実をモデリングしたプログラムコードによって開発者は安定した軸足を得られる
    - 人がなんと言おうと事実な部分
    - アプリケーションのどこから見てもそうとしか言えないような、普遍的な概念関係とロジック
        - 商品と数量によって会計が生成されるなど
- 2層目: ユースケース
    - ユーザーが行う操作を表現するロジックをここに入れる
    - これを「ユースケース」と呼ぶ
    - ユースケースは安定した「ドメインモデル」への依存しかない
        - かなりの安定を期待できる
    - 人が何をしたいかの部分
- 3層目: インターフェースアダプター
    - ソフトウェアをユーザーに使ってもらうには、実際に実行できるアプリケーションとして形にする必要がある
    - コントローラなどの役割
    - アプリケーションの枠組み作り
- 4層目: インフラストラクチャ
    - 実際の入出力の詳細や画面との繋ぎ込みといった具体的な技術的問題の解決
    - アプリケーションの実動作の全てを担う
    - 下支えとしての動作の実態

## 依存性反転原則（DIP）

TODO: もっとちゃんと理解したい

- DIPは、オブジェクト指向プログラミングで「疎結合」を実現しようとするとき、制御の向きと依存の向きが必ず逆の関係になること
- モジュールの機能を呼び出すことと、そのモジュールに依存することが同じ意味になるのは、直感的に理解しやすい関係
- 「疎結合にする」とは、この直感的な依存関係に反して、振る舞いの実装を無視した依存関係を成り立たせること、つまり`インターフェースに依存せよ`ということ
- 抽象メソッドを呼び出しておけば、振る舞い実装なしでもロジックを完結させられる

## リンク

- The Clean Architecture
    - https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

## 個人的メモ

- 良い設計・コードとは？
    - 「変更するのが怖くない」コード
        - 「柔らかい」コード
        - つまり、`疎結合`かつ`高凝集`
            - 影響範囲の特定が容易
            - `このクラス・メソッドは何をするクラス・メソッドか`に明確に答えられること
- 設計や実装を磨く行為
    - 柔軟体操みたいなもの
