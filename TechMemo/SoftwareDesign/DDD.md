## DDDのコンセプト

- ビジネスの問題を解決するためにビジネスの理解を深め、ビジネスの表現をする
    - ドメインの概念や事象を理解し、その中から問題解決に役立つものを抽出して得られた知識をソフトウェアに反映させる
    - これは、技術指向の開発者であればあるほど疎かにしやすい工程でもある
- ビジネスとコードを結びつけて、継続的かつ反復的な改良を施せるように枠組みを作ることにより、ソフトウェアをより役立つものにしようとする

## DDDとは？

- DDD=ソフトウェアを適用する領域駆動設計
- まず`ドメインモデルを際立たせ`、それがプロジェクトを牽引すべきだとする思想
- コードによるモデリングを中心とし、顧客との反復的な対話を通じて、モデルに表された要求を洗練していくのがDDDの活動
- ものを作るとき、必ず必要になる「知識」が存在する（ex. 物流システムなら物流の知識など）
- ソフトウェアを作るにあたって必要な知識を取捨選択しつつ、その知識をコードに埋め込むことを実現するのが「ドメイン駆動設計」
- 具体的には、「ドメインについて学ぶ -> ドメインモデルを作り上げる -> ドメインオブジェクトとして実装する」の流れを実践する

## ドメインとは？

- ソフトウェアにおけるドメイン=プログラム（ソフトウェア）を適用する対象となる領域
    - ex. メルカリ=フリーマーケット、マネーフォワード=家計簿

ex. 会計システムなら金銭や帳票など

## ドメインモデルとは？

- モデル=現実の事象・あるいは概念を抽象化した概念
- ドメインモデル=モデリングをして得られたモデル
- ドメインの知識を持っているドメインの世界の住人と、開発の知識をもっている開発者は協力（相互補完）しながらドメインモデルを作り上げる必要がある
    - `ドメインモデルを作る作業を開発者だけで完結することは不可能`
    - ドメインの概念に対する捉え方はドメイン実践者の視点が欠かせない
        - ここ中々できないよなあ...
        - 一番大事な気がする

## ドメインオブジェクトとは？

- ドメインモデルは、それだけでは何も解決できない
- ソフトウェアとして形にされることで力を発揮する
- ドメインモデルをソフトウェアで動作するモジュールとして表現したのが「ドメインオブジェクト」

### ドメインオブジェクトを定義するメリット

- エンティティや値オブジェクトなどのドメインオブジェクトを定義するメリット
    - コードのドキュメント性が高まる
    - ドメインにおける変更をコードに伝えやすくする

### ドメインモデル貧血症とは？

- ドメインモデルを作りながらも、フィールドのGetter/Setterだけをつものを指す
- ドメインオブジェクトに業務知識が実装されず、それを使う側に任されることになる

## DDDの用語

二つに大別される。

- モデリング
    - ソフトウェアにとって重要な概念を抽出して抽象化する
- パターン
    - 概念を実装に落とし込む

## DDDの「パターン」の分類について

- ドメインの知識を表現するためのパターン
    - 集約
        - 整合性を保つ境界
        - 値オブジェクトやエンティティといったドメインオブジェクトを束ねて複雑なドメインの概念を表現する
    - 値オブジェクト
        - ドメイン固有の概念（金銭や製造番号など）を値として表現するパターン
    - エンティティ
        - 値オブジェクトと同じくドメインの概念を表現するオブジェクトであるが、値オブジェクトとは対をなすような性質がある
    - ドメインサービス
        - 値オブジェクトやエンティティではうまく表現ができない知識を取り扱うためのパターン
    - 仕様
        - オブジェクトの評価をする
- アプリケーションを実現するためのパターン
    - アプリケーションサービス
        - 値オブジェクト・エンティティ・ドメインサービス・リポジトリの4つの要素を強調させ、アプリケーションとして成り立たせる場がアプリケーションサービス
    - ファクトリ
        - オブジェクトを作る知識に特化したオブジェクト
    - リポジトリ
        - データの保存や復元といった永続化や再構築を担当するオブジェクト
- アプリケーションを実現するためのパターンはドメインの知識を表現するためのパターンを使用する

## 値オブジェクト

- システム固有の`値`を表現するためのオブジェクト
- システムに最適な「値」は必ずしもプリミティブ（単なる変数など、オブジェクトでなく、メソッドを持たないデータのこと）とは限らない
- プリミティブな値は表現力が乏しい
- オブジェクトにした方が適切な場合もある
- DDDでは、このような`システム固有の値`を表現した`オブジェクト`を「値オブジェクト」と呼ぶ

「値」は以下の性質を持っている。そして、「値オブジェクト」にも全く同じ性質が当てはまる。

- 不変である
    - 1という数値がある日突然0になったら..?どう考えても辛い
    - 値は不変であるからこそ、安全に使用できる
    - 値オブジェクトも「値」である以上、値オブジェクトに値を変更するメソッドを定義することは基本的には許されない
        - ex. Moneyの値オブジェクトでお金の加算をするときも、Addメソッド内でMoneyのオブジェクトを再度生成して返す
    - 不変のメリット
        - 値オブジェクトに限らず、システムを作る上で「不変」には大きなメリットがある
        - 「生成したインスタンスをメソッドに渡したら、いつの間にかインスタンスの値や状態が変更されていた」という状況は意図せぬ挙動となりバグを引き起こす

- 交換が可能である
    - 値オブジェクトはそれ自体を変更することはできない
    - 値オブジェクトの変更は代入操作によって行う
```c++
// 以下は値（値オブジェクト）そのものを変更しているので許されない
var fullName = new FullName("taro", "yamada");
fullName.ChangeLastName("sato");

// 以下はOK
var fullName = new FullName("taro", "yamada");
fullName = new FullName("jiro", "yamada");
```

- 等価性によって比較される
    - `0 === 0`の左右の値は、インスタンスとして別のものだが、等価として扱われる
    - 値は値自身ではなく、それを構成する「属性」によって評価される
    - 値オブジェクトも、値オブジェクトを構成する属性（インスタンス変数）によって比較される
値オブジェクトはあくまで「値」なので、以下のように値の属性を取り出して比較するのはおかしい。
```c++
// nameA,Bは値オブジェクト
var compareResult = nameA.FirstName === nameB.FirstName;

// 以下と同じ意味合いになってしまう..
Console.WriteLine(1.value == 0.value);
```
値オブジェクトはあくまで「値」そのものなので、その属性を取り出して比較するのではなく、値と同じようにオブジェクト同士が比較できるようにするのが自然。
そして、このような記述を行うには、値オブジェクト自身が「比較のためのメソッド」を提供する必要がある。
```c++
var compareResult = nameA.Equals(nameB);
```

### 値オブジェクトにする「基準」について

- 値オブジェクトにすべきかの判断基準
    - そこにルールが存在しているか
        - ex. 氏名には「姓と名で構成される」というルールが存在している
    - それ単体で取り扱いたいか

### 値オブジェクトを採用する理由 

- 表現力を増す
    - 自身の定義により、自分がどういったもの（値）であるかを主張する（自己文書化）
- 不正な値を存在させない
- 誤った代入を防ぐ
    - 単なる文字列ではなく、`UserName`のような値オブジェクトとして表現することで、型の恩恵に与ることができる
- ロジックの散在を防ぐ
    - 例えばユーザーの名前の文字数制限などのロジックを値オブジェクト内に閉じ込めることができる

## エンティティ

- 値オブジェクトと対をなすドメインオブジェクト
- 値オブジェクトとの違いは、「同一性によって識別されるか」否か
- 例えば`User`などはその典型
- Userの属性（身長とか名前とか）が変わったからと言って、そのUserが別人になるわけではない
- Userはあくまで「同一性（Identity）」によって区別される
- 逆に「姓名」などは「同一性」ではなく「属性」によって区別される
    - 姓や名が変われば全く別のものになる
    - また、姓名の値が同じであれば同じものとみなされる

- エンティティの性質は以下の通り
    - 可変である
        - 人の身長や体重が変わるように、エンティティの属性は変化することが許されている
            - ex. Userオブジェクト内のchangeNameメソッドで変更する
            - 値オブジェクトは不変の性質があるため交換（代入）によって変更を表現していたが、エンティティは交換により変更を行わない
            - エンティティの属性を変化させたいときは、その振る舞いを通じて属性を変更する
    - 同じ属性であっても区別される
        - 人間の場合は同姓同名であっても別人として扱われるよね
        - エンティティ同士を区別するためには識別子（Identity）が利用される
            - 識別子は不変にする
    - 同一性により区別される
        - エンティティには同一性を判定するメソッドを追加することが多い（Equalsメソッドなど）
        - 識別子（ID）だけが比較の対象となる

### エンティティにするか値オブジェクトにするかの判断基準

- `ライフサイクル`が存在し、そこに`連続性`が存在するかというのが大きな判断基準
- ユーザーには「作成 -> 属性の変更 -> 削除」などのライフサイクルがある
    - ライフサイクルを持ち、連続性のある概念
- ライフサイクルを持たない、またはシステムにとってライフサイクルを表現することが無意味である場合には、ひとまずは値オブジェクトとして取り扱うと良い

## ドメインサービス

### 概要

- ドメインの概念を知識として落とし込み、それをコードで表現しようとしたとき、値オブジェクトやエンティティの振る舞いとして定義すると違和感が生じるものが存在する
- この違和感は、ドメインのものを表現しようとしたときよりも、ドメインの活動を表現しようとするときに見られる傾向がある
- 違和感のある振る舞いを値オブジェクトなどに無理やり実装しようとすると、オブジェクトの責務を歪なものに変えてしまう
- このようなときに求められることは、その振る舞いを別のオブジェクトとして定義すること
- ドメインサービスはまさにそのオブジェクト

### サービスとは？

- ソフトウェアの文脈における「サービス」はクライアントのために何かを行うオブジェクト
- ドメイン駆動設計における「サービス」は以下の二つ
    - ドメインサービス
        - ドメインのためのサービス
    - アプリケーションサービス
        - アプリケーションのためのサービス

### ドメインサービスとは？

- 例えば、Userオブジェクトの同姓同名を許容しないアプリケーションがあって、同姓同名のUserが既に存在しているかどうかをチェックしたい場合、そのチェックの処理をどこに記述するか？
- Userクラスに定義するのは`違和感`がある
    - Userオブジェクト自身に他に重複するユーザーがあるかどうかを聞く？
- こういった`不自然`で`違和感`のある振る舞いを記述するために使用するのが「ドメインサービス」
- 以下のように記述する
```java
class UserService
{
    public bool Exists(User user)
    {
        // 重複確認
        // ...
    }
}
```

## DDD参考リンク

- [ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本](https://www.shoeisha.co.jp/book/detail/9784798150727)
- [【DDD入門】TypeScript × ドメイン駆動設計ハンズオン](https://zenn.dev/yamachan0625/books/ddd-hands-on)
- [DDDはなぜ難しいのか / 良いコードの定義と設計能力の壁](https://speakerdeck.com/pospome/liang-ikodonoding-yi-toshe-ji-neng-li-nobi)

## TODO

- 軽量DDD
- 戦略的設計・戦術的設計