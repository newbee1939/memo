## DDDのコンセプト

- ビジネスの問題を解決するためにビジネスの理解を深め、ビジネスの表現をする
    - ドメインの概念や事象を理解し、その中から問題解決に役立つものを抽出して得られた知識をソフトウェアに反映させる
    - これは、技術指向の開発者であればあるほど疎かにしやすい工程でもある
- ビジネスとコードを結びつけて、継続的かつ反復的な改良を施せるように枠組みを作ることにより、ソフトウェアをより役立つものにしようとする

## DDDとは？

- まず`ドメインモデルを際立たせ`、それがプロジェクトを牽引すべきだとする思想
- コードによるモデリングを中心とし、顧客との反復的な対話を通じて、モデルに表された要求を洗練していくのがDDDの活動
- ものを作るとき、必ず必要になる「知識」が存在する（ex. 物流システムなら物流の知識など）
- ソフトウェアを作るにあたって必要な知識を取捨選択しつつ、その知識をコードに埋め込むことを実現するのが「ドメイン駆動設計」

## ドメインとは？

ソフトウェアにおけるドメイン=プログラムを適用する対象となる領域

ex. 会計システムなら金銭や帳票など

## ドメインモデルとは？

- モデル=現実の事象・あるいは概念を抽象化した概念
- ドメインモデル=モデリングをして得られたモデル
- ドメインの知識を持っているドメインの世界の住人と、開発の知識をもっている開発者は協力（相互補完）しながらドメインモデルを作り上げる必要がある
    - `ドメインモデルを作る作業を開発者だけで完結することは不可能`
    - ドメインの概念に対する捉え方はドメイン実践者の視点が欠かせない
        - ここ中々できないよなあ...

## ドメインオブジェクトとは？

- ドメインモデルは、それだけでは何も解決できない
- ソフトウェアとして形にされることで力を発揮する
- ドメインモデルをソフトウェアで動作するモジュールとして表現したのが「ドメインオブジェクト」

## DDDの用語

二つに大別される。

- モデリング
    - ソフトウェアにとって重要な概念を抽出して抽象化する
- パターン
    - 概念を実装に落とし込む

## DDDの「パターン」の分類について

- ドメインの知識を表現するためのパターン
    - 集約
        - 整合性を保つ境界
        - 値オブジェクトやエンティティといったドメインオブジェクトを束ねて複雑なドメインの概念を表現する
    - 値オブジェクト
        - ドメイン固有の概念（金銭や製造番号など）を値として表現するパターン
    - エンティティ
        - 値オブジェクトと同じくドメインの概念を表現するオブジェクトであるが、値オブジェクトとは対をなすような性質がある
    - ドメインサービス
        - 値オブジェクトやエンティティではうまく表現ができない知識を取り扱うためのパターン
    - 仕様
        - オブジェクトの評価をする
- アプリケーションを実現するためのパターン
    - アプリケーションサービス
        - 値オブジェクト・エンティティ・ドメインサービス・リポジトリの4つの要素を強調させ、アプリケーションとして成り立たせる場がアプリケーションサービス
    - ファクトリ
        - オブジェクトを作る知識に特化したオブジェクト
    - リポジトリ
        - データの保存や復元といった永続化や再構築を担当するオブジェクト
- アプリケーションを実現するためのパターンはドメインの知識を表現するためのパターンを使用する

## 値オブジェクト

- システム固有の`値`を表現するためのオブジェクト
- システムに最適な「値」は必ずしもプリミティブ（単なる変数など、オブジェクトでなく、メソッドを持たないデータのこと）とは限らない
- プリミティブな値は表現力が乏しい
- オブジェクトにした方が適切な場合もある
- DDDでは、このような`システム固有の値`を表現した`オブジェクト`を「値オブジェクト」と呼ぶ

「値」は以下の性質を持っている。そして、「値オブジェクト」にも全く同じ性質が当てはまる。

- 不変である
    - 1という数値がある日突然0になったら..?どう考えても辛い
    - 値は不変であるからこそ、安全に使用できる
    - 値オブジェクトも「値」である以上、値オブジェクトに値を変更するメソッドを定義することは基本的には許されない
        - ex. Moneyの値オブジェクトでお金の加算をするときも、Addメソッド内でMoneyのオブジェクトを再度生成して返す
    - 不変のメリット
        - 値オブジェクトに限らず、システムを作る上で「不変」には大きなメリットがある
        - 「生成したインスタンスをメソッドに渡したら、いつの間にかインスタンスの値や状態が変更されていた」という状況は意図せぬ挙動となりバグを引き起こす

- 交換が可能である
    - 値オブジェクトはそれ自体を変更することはできない
    - 値オブジェクトの変更は代入操作によって行う
```c++
// 以下は値（値オブジェクト）そのものを変更しているので許されない
var fullName = new FullName("taro", "yamada");
fullName.ChangeLastName("sato");

// 以下はOK
var fullName = new FullName("taro", "yamada");
fullName = new FullName("jiro", "yamada");
```

- 等価性によって比較される
    - `0 === 0`の左右の値は、インスタンスとして別のものだが、等価として扱われる
    - 値は値自身ではなく、それを構成する「属性」によって評価される
    - 値オブジェクトも、値オブジェクトを構成する属性（インスタンス変数）によって比較される
値オブジェクトはあくまで「値」なので、以下のように値の属性を取り出して比較するのはおかしい。
```c++
// nameA,Bは値オブジェクト
var compareResult = nameA.FirstName === nameB.FirstName;

// 以下と同じ意味合いになってしまう..
Console.WriteLine(1.value == 0.value);
```
値オブジェクトはあくまで「値」そのものなので、その属性を取り出して比較するのではなく、値と同じようにオブジェクト同士が比較できるようにするのが自然。
そして、このような記述を行うには、値オブジェクト自身が「比較のためのメソッド」を提供する必要がある。
```c++
var compareResult = nameA.Equals(nameB);
```

### 値オブジェクトにする「基準」について

- 値オブジェクトにすべきかの判断基準
    - そこにルールが存在しているか
        - ex. 氏名には「姓と名で構成される」というルールが存在している
    - それ単体で取り扱いたいか

### 値オブジェクトを採用する理由 

- 表現力を増す
    - 自身の定義により、自分がどういったもの（値）であるかを主張する（自己文書化）
- 不正な値を存在させない
- 誤った代入を防ぐ
    - 単なる文字列ではなく、`UserName`のような値オブジェクトとして表現することで、型の恩恵に与ることができる
- ロジックの散在を防ぐ
    - 例えばユーザーの名前の文字数制限などのロジックを値オブジェクト内に閉じ込めることができる

## エンティティ

- 値オブジェクトと対をなすドメインオブジェクト
- 値オブジェクトとの違いは、「同一性によって識別されるか」否か
- 例えば`User`などはその典型
- Userの属性（身長とか名前とか）が変わったからと言って、そのUserが別人になるわけではない
- Userはあくまで「同一性（Identity）」によって区別される
- 逆に「姓名」などは「同一性」ではなく「属性」によって区別される
    - 姓や名が変われば全く別のものになる
    - また、姓名の値が同じであれば同じものとみなされる

- エンティティの性質は以下の通り
    - 可変である
    - 同じ属性であっても区別される
    - 同一性により区別される

## 参考

- 書籍: ドメイン駆動設計入門
- [【DDD入門】TypeScript × ドメイン駆動設計ハンズオン](https://zenn.dev/yamachan0625/books/ddd-hands-on)

## TODO

- 軽量DDD
- 戦略的設計・戦術的設計