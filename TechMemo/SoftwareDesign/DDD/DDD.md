## DDDのコンセプト

- ビジネスの問題を解決するためにビジネスの理解を深め、ビジネスの表現をする
    - ドメインの概念や事象を理解し、その中から問題解決に役立つものを抽出して得られた知識をソフトウェアに反映させる
    - これは、技術指向の開発者であればあるほど疎かにしやすい工程でもある
- ビジネスとコードを結びつけて、継続的かつ反復的な改良を施せるように枠組みを作ることにより、ソフトウェアをより役立つものにしようとする

## DDDとは？

- DDD=ソフトウェアを適用する領域駆動設計
- まず`ドメインモデルを際立たせ`、それがプロジェクトを牽引すべきだとする思想
- コードによるモデリングを中心とし、顧客との反復的な対話を通じて、モデルに表された要求を洗練していくのがDDDの活動
- ものを作るとき、必ず必要になる「知識」が存在する（ex. 物流システムなら物流の知識など）
- ソフトウェアを作るにあたって必要な知識を取捨選択しつつ、その知識をコードに埋め込むことを実現するのが「ドメイン駆動設計」
- 具体的には、「ドメインについて学ぶ -> ドメインモデルを作り上げる -> ドメインオブジェクトとして実装する」の流れを実践する

## ドメインとは？

- ソフトウェアにおけるドメイン=プログラム（ソフトウェア）を適用する対象となる領域
    - ex. メルカリ=フリーマーケット、マネーフォワード=家計簿

ex. 会計システムなら金銭や帳票など

## ドメインモデルとは？

- モデル=現実の事象・あるいは概念を抽象化した概念
- ドメインモデル=モデリングをして得られたモデル
- ドメインの知識を持っているドメインの世界の住人と、開発の知識をもっている開発者は協力（相互補完）しながらドメインモデルを作り上げる必要がある
    - `ドメインモデルを作る作業を開発者だけで完結することは不可能`
    - ドメインの概念に対する捉え方はドメイン実践者の視点が欠かせない
        - ここ中々できないよなあ...
        - 一番大事な気がする

## ドメインオブジェクトとは？

- ドメインモデルは、それだけでは何も解決できない
- ソフトウェアとして形にされることで力を発揮する
- ドメインモデルをソフトウェアで動作するモジュールとして表現したのが「ドメインオブジェクト」
- ドメインオブジェクトはドメインのコード上の現身

### ドメインオブジェクトを定義するメリット

- エンティティや値オブジェクトなどのドメインオブジェクトを定義するメリット
    - コードのドキュメント性が高まる
    - ドメインにおける変更をコードに伝えやすくする

### ドメインモデル貧血症とは？

- ドメインモデルを作りながらも、フィールドのGetter/Setterだけをつものを指す
- ドメインオブジェクトに業務知識が実装されず、それを使う側に任されることになる

## DDDの用語

二つに大別される。

- モデリング
    - ソフトウェアにとって重要な概念を抽出して抽象化する
- パターン
    - 概念を実装に落とし込む

## DDDの「パターン」の分類について

- ドメインの知識を表現するためのパターン
    - 集約
        - 整合性を保つ境界
        - 値オブジェクトやエンティティといったドメインオブジェクトを束ねて複雑なドメインの概念を表現する
    - 値オブジェクト
        - ドメイン固有の概念（金銭や製造番号など）を値として表現するパターン
    - エンティティ
        - 値オブジェクトと同じくドメインの概念を表現するオブジェクトであるが、値オブジェクトとは対をなすような性質がある
    - ドメインサービス
        - 値オブジェクトやエンティティではうまく表現ができない知識を取り扱うためのパターン
    - 仕様
        - オブジェクトの評価をする
- アプリケーションを実現するためのパターン
    - アプリケーションサービス
        - 値オブジェクト・エンティティ・ドメインサービス・リポジトリの4つの要素を強調させ、アプリケーションとして成り立たせる場がアプリケーションサービス
    - ファクトリ
        - オブジェクトを作る知識に特化したオブジェクト
    - リポジトリ
        - データの保存や復元といった永続化や再構築を担当するオブジェクト
- アプリケーションを実現するためのパターンはドメインの知識を表現するためのパターンを使用する

## 値オブジェクト

- システム固有の`値`を表現するためのオブジェクト
- システムに最適な「値」は必ずしもプリミティブ（単なる変数など、オブジェクトでなく、メソッドを持たないデータのこと）とは限らない
- プリミティブな値は表現力が乏しい
- オブジェクトにした方が適切な場合もある
- DDDでは、このような`システム固有の値`を表現した`オブジェクト`を「値オブジェクト」と呼ぶ

「値」は以下の性質を持っている。そして、「値オブジェクト」にも全く同じ性質が当てはまる。

- 不変である
    - 1という数値がある日突然0になったら..?どう考えても辛い
    - 値は不変であるからこそ、安全に使用できる
    - 値オブジェクトも「値」である以上、値オブジェクトに値を変更するメソッドを定義することは基本的には許されない
        - ex. Moneyの値オブジェクトでお金の加算をするときも、Addメソッド内でMoneyのオブジェクトを再度生成して返す
    - 不変のメリット
        - 値オブジェクトに限らず、システムを作る上で「不変」には大きなメリットがある
        - `生成したインスタンスをメソッドに渡したら、いつの間にかインスタンスの値や状態が変更されていた`という状況は意図せぬ挙動となりバグを引き起こす

- 交換が可能である
    - 値オブジェクトはそれ自体を変更することはできない
    - 値オブジェクトの変更は代入操作によって行う
```c++
// 以下は値（値オブジェクト）そのものを変更しているので許されない
var fullName = new FullName("taro", "yamada");
fullName.ChangeLastName("sato");

// 以下はOK
var fullName = new FullName("taro", "yamada");
fullName = new FullName("jiro", "yamada");
```

- 等価性によって比較される
    - `0 === 0`の左右の値は、インスタンスとして別のものだが、等価として扱われる
    - 値は値自身ではなく、それを構成する「属性」によって評価される
    - 値オブジェクトも、値オブジェクトを構成する属性（インスタンス変数）によって比較される
値オブジェクトはあくまで「値」なので、以下のように値の属性を取り出して比較するのはおかしい。
```c++
// nameA,Bは値オブジェクト
var compareResult = nameA.FirstName === nameB.FirstName;

// 以下と同じ意味合いになってしまう..
Console.WriteLine(1.value == 0.value);
```
値オブジェクトはあくまで「値」そのものなので、その属性を取り出して比較するのではなく、値と同じようにオブジェクト同士が比較できるようにするのが自然。
そして、このような記述を行うには、値オブジェクト自身が「比較のためのメソッド」を提供する必要がある。
```c++
var compareResult = nameA.Equals(nameB);
```

### 値オブジェクトにする「基準」について

- 値オブジェクトにすべきかの判断基準
    - そこにルールが存在しているか
        - ex. 氏名には「姓と名で構成される」というルールが存在している
    - それ単体で取り扱いたいか

### 値オブジェクトを採用する理由 

- 表現力を増す
    - 自身の定義により、自分がどういったもの（値）であるかを主張する（自己文書化）
- 不正な値を存在させない
- 誤った代入を防ぐ
    - 単なる文字列ではなく、`UserName`のような値オブジェクトとして表現することで、型の恩恵に与ることができる
- ロジックの散在を防ぐ
    - 例えばユーザーの名前の文字数制限などのロジックを値オブジェクト内に閉じ込めることができる

## エンティティ

- 値オブジェクトと対をなすドメインオブジェクト
- 値オブジェクトとの違いは、「同一性によって識別されるか」否か
- 例えば`User`などはその典型
- Userの属性（身長とか名前とか）が変わったからと言って、そのUserが別人になるわけではない
- Userはあくまで「同一性（Identity）」によって区別される
- 逆に「姓名」などは「同一性」ではなく「属性」によって区別される
    - 姓や名が変われば全く別のものになる
    - また、姓名の値が同じであれば同じものとみなされる

- エンティティの性質は以下の通り
    - 可変である
        - 人の身長や体重が変わるように、エンティティの属性は変化することが許されている
            - ex. Userオブジェクト内のchangeNameメソッドで変更する
            - 値オブジェクトは不変の性質があるため交換（代入）によって変更を表現していたが、エンティティは交換により変更を行わない
            - エンティティの属性を変化させたいときは、その振る舞いを通じて属性を変更する
    - 同じ属性であっても区別される
        - 人間の場合は同姓同名であっても別人として扱われるよね
        - エンティティ同士を区別するためには識別子（Identity）が利用される
            - 識別子は不変にする
    - 同一性により区別される
        - エンティティには同一性を判定するメソッドを追加することが多い（Equalsメソッドなど）
        - 識別子（ID）だけが比較の対象となる

### エンティティにするか値オブジェクトにするかの判断基準

- `ライフサイクル`が存在し、そこに`連続性`が存在するかというのが大きな判断基準
- ユーザーには「作成 -> 属性の変更 -> 削除」などのライフサイクルがある
    - ライフサイクルを持ち、連続性のある概念
- ライフサイクルを持たない、またはシステムにとってライフサイクルを表現することが無意味である場合には、ひとまずは値オブジェクトとして取り扱うと良い

## ドメインサービス

### 概要

- ドメインの概念を知識として落とし込み、それをコードで表現しようとしたとき、値オブジェクトやエンティティの振る舞いとして定義すると違和感が生じるものが存在する
- この違和感は、ドメインのものを表現しようとしたときよりも、ドメインの活動を表現しようとするときに見られる傾向がある
- 違和感のある振る舞いを値オブジェクトなどに無理やり実装しようとすると、オブジェクトの責務を歪なものに変えてしまう
- このようなときに求められることは、その振る舞いを別のオブジェクトとして定義すること
- ドメインサービスはまさにそのオブジェクト

### サービスとは？

- ソフトウェアの文脈における「サービス」は`クライアントのために何かを行うオブジェクト`
- ドメイン駆動設計における「サービス」は以下の二つ
    - ドメインサービス
        - ドメインのためのサービス
        - ドメインにおける活動
        - 矢印がドメインに向いている
    - アプリケーションサービス
        - アプリケーションのためのサービス
        - アプリケーションとして成り立たせるためのサービス
        - 矢印がアプリケーションに向いている
- ドメインオブジェクトは自身のためのふるまいを持っているが、サービスは自身のためのふるまいは持っていない
    - サービスはものごとではなく、活動や行動であることが多い

### ドメインサービスとは？

- 例えば、Userオブジェクトの同姓同名を許容しないアプリケーションがあって、同姓同名のUserが既に存在しているかどうかをチェックしたい場合、そのチェックの処理をどこに記述するか？
- Userクラスに定義するのは`違和感`がある
    - Userオブジェクト自身に他に重複するユーザーがあるかどうかを聞く？
- こういった`不自然`で`違和感`のある振る舞いを記述するために使用するのが「ドメインサービス」
- 例えば複数のドメインオブジェクトを横断するような操作など
- 以下のように記述する
```java
class UserService
{
    public bool Exists(User user)
    {
        // 重複確認
        // ...
    }
}
```
- ドメインサービスは、値オブジェクトやエンティティと異なり、自身のふるまいを変更するようなインスタンス特有の状態を持たないオブジェクト
- ここで大事なのは、ドメインサービスに実装するのは、「ドメインオブジェクトに実装すると違和感があるもの」に限定すること
- そうしないと、あらゆる処理がドメインサービスに実装されていってしまう
    - `ドメインモデル貧血症`（ドメインオブジェクトに記述されるべき知識や振る舞いがドメインサービス等に記述され、語るべきことを何も語っていないオブジェクトの状態）を招く
- 迷ったらドメインオブジェクトに実装する
- なるべくドメインサービスには実装しない

### ドメインサービスの命名規則について

- ドメインサービスの命名規則は主に3パターン
    - ドメインの概念
    - ドメインの概念 + サービス
    - ドメインの概念 + DomainService
- サービスはドメインの活動がその対象となりやすく、動詞に基づいて命名されることが多い

## リポジトリ

- リポジトリ=データの保管庫
- リポジトリはデータにまつわる処理を分離する
- そして、永続化や再構築（データの取得）を担う
- データの永続化や再構築等の処理をドメインサービスからリポジトリの切り出すことで、ドメインサービスの役割がよりはっきりする（無駄に長い永続化や再構築の処理が抽象化されるので）
    - ドメインオブジェクトを際立たせることができる
- さらに、データストアにまつわる処理を切り出すことで、データストアの差し替えも容易にすることができる
    - `インターフェース`をうまく活用することで、より差し替えを容易にできる
- リポジトリ内の処理は、SQLを直接記述するだけでなく、ORMを使って記述することもできる

### リポジトリに定義する振る舞い

リポジトリでは、以下のように更新項目を引き渡す更新処理は行わない。
リポジトリに多くの更新処理を定義させる結果に繋がってしまうので。。

```java
interface IUserRepository
{
    void UpdateName(UserId id, UserName name)
    ...
}
```

永続化のふるまいは永続化を行うオブジェクトを引数に取るようにする。
オブジェクトが保持するデータを更新するなら、ドメインオブジェクト自身に依頼すべき。

```java
interface IUserRepository
{
    void Save(User user)
    ...
}
```

同様にオブジェクトを生成する処理もリポジトリには定義しない。
データの破棄の処理はリポジトリに実装する。

再構築の振る舞いは識別によって検索されるメソッドで、以下のように記述する。

```java
interface IUserRepository
{
    User Find(UserId id);
    ...
}
```

## アプリケーションサービス

### 概要

- 端的に言うと、「ユースケースを実現するオブジェクト」
- アプリケーションサービスはドメインオブジェクトを強調させてユースケースを実現する
- 値オブジェクトやエンティティといったドメインオブジェクトはドメインモデルをコードによって表現したオブジェクト
- ソフトウェアとして利用者の問題を解決するには、これらのドメインオブジェクトをまとめあげて問題を解決するように導く必要がある
- アプリケーションサービスはドメインオブジェクトが行うタスクの進行を管理し、問題の解決に導く

### アプリケーションサービスでドメインオブジェクトの取得をする場合

- ドメインオブジェクトをクライアントにそのまま返すべきか？
- アプリケーションサービス以外のオブジェクトがドメインオブジェクトの直接のクライアントとなって自由に操作できてしまうのは問題
- ドメインオブジェクトの振る舞いを呼び出すのはアプリケーションサービスの役割
- その枠組みを越えてドメインオブジェクトの振る舞いが呼び出されてしまうと、本来であればアプリケーションサービスとして提供されるべきであったコードが各所に散りばめられてしまう
- また、ドメインオブジェクトに対する依存が多く生まれるのも問題
- ドメインオブジェクトを変更しづらくなる
- ドメインの変更をドメインオブジェクトに反映させるスピードが落ちる
- そこでおすすめなのが、ドメインオブジェクトを直接公開しない方法
- ドメインオブジェクトを非公開としたとき、クライアントには`データ転送用オブジェクト（DTO, Data Transfer Object）`にデータを移し替えて返却する
- これにより、クライアントはドメインオブジェクトのメソッドを呼び出せなくなる（ドメインオブジェクトの操作ができなくなる）
- 以下に具合例を示す

```java
// DTO
public class UserData
{
    public UserData(string id, string name)
    {
        Id = id;
        Name = name;
        
        public string Id { get; }
        public string Name { get; }
    }
}
```

```java
public class UserApplicationService
{
    private readOnly IUserRepository userRepository;

    public UserData Get(string userId)
    {
        var targetId = new UserId(userId);
        var user = userRepository.Find(targetId);

        // DTOに詰め替える
        var userData = new UserData(user.Id.Value, user.Name.Value);
        return userData;
    }
}
```

### アプリケーションサービスの役割について

- アプリケーションサービスはあくまでドメインオブジェクトの操作や調整に徹するべき 
- アプリケーションサービス内にドメインのルールは記述されるべきではない
- アプリケーションサービス内にドメインのルールは記述すると、様々なファイルに同じようなロジックが点在する事態になってしまう可能性がある
- ドメインのルールはドメインオブジェクトに実装する

### アプリケーションサービスの分割について

classの凝集度を高めるために、以下のようにファイルを分割するパターンも多い。

- Application
    - Users
        - UserRegisterService
        - UserGetInfoService
        - UserUpdateInfoService
        - UserDeleteService

また、アプリケーションサービスはインターフェースを通すことも多い。

### サービスは状態を持たない

- アプリケーションサービスが状態（インスタンス変数など）を持ってしまうと、クライアント側がアプリケーションサービスの状態を気にしなくてはならなくなる
- 状態がもたらす複雑さは多くの開発者を混乱させる

### ユースケースについてとアプリケーションサービスの違いについて

TODO

## 依存関係のコントロール

### 概要

- ソフトウェアに柔軟性をもたらすために必要なことは「依存関係を制御」すること
- 依存関係を軽視すると、ソフトウェアは途端に柔軟性を失う
- ソフトウェアを柔軟に保つために必要なことは、特定の技術要素への依存を避け、変更の主導権を`抽象`に移すこと
- 重要なのは、依存を「避ける」のではなく、「コントロール」すること

### 依存性逆転の法則について

以下のアプリケーションサービスとリポジトリについて、アプリケーションがリポジトリで使用されている特定の技術基盤に依存しているのは問題である。

```
UserApplicationService -----> UserRepository
```

そこでUserRepositoryのインターフェースを用意する。（IUserRepository）
アプリケーションサービスはリポジトリを直接見るのではなく、インターフェースを参照するようにする。

```
UserApplicationService -----> IUserRepository <----- UserRepository
```

もともと具体的な実装に依存していたものが抽象に依存するように、`依存関係は逆転`した。

これにより、アプリケーションサービスが特定の技術に依存しているリポジトリに直接依存することはなくなる。

抽象型（インターフェース）を利用すると、具象型に向いていた依存の矢印が抽象型へ向くようになる。
このように依存の方向性を制御し、全てのモジュールが抽象へ依存するように制御することは、ビジネスロジックを具体的な実装から解き放ち、より純粋なものに昇華する効果がある。

この抽象型を用いた依存関係の制御は「依存関係逆転の原則（Dependency Inversion Principle）」として知られている。

### 依存関係逆転の原則とは？

DIPは以下のように定義されている。

- 上位レベルのモジュールは下位モジュールに依存してはならない、どちらのモジュールも抽象に依存すべきである
- 抽象は、実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである

### 依存関係をコントロールする

以下のように実装してしまうと、あらゆる箇所でリポジトリの種類を切り替える必要がある。

```java
public class UserApplicationService
{
    private readonly IUserRepository userRepository;

    public UserApplicationsService()
    {
        // this.userRepository = new InMemoryUserRepository();
        this.userRepository = new UserRepository();
    }
    
    ...
}
```

## モデルとエンティティの違い

TODO
本にある？

## MVCのModelとは？エンティティとの違いは？

https://allabout-tech.hatenablog.com/entry/2016/11/29/100000

## DDD参考リンク

- [ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本](https://www.shoeisha.co.jp/book/detail/9784798150727)
- [【DDD入門】TypeScript × ドメイン駆動設計ハンズオン](https://zenn.dev/yamachan0625/books/ddd-hands-on)
- [DDDはなぜ難しいのか / 良いコードの定義と設計能力の壁](https://speakerdeck.com/pospome/liang-ikodonoding-yi-toshe-ji-neng-li-nobi)

## TODO

- 軽量DDD
- 戦略的設計・戦術的設計
- DDDイラストの完成と定期的な更新
    - https://www.canva.com/design/DAGA94WP2ZI/G_UA4aBkxDcCknudtHvz_w/edit
    - 再度このページを読み返しつつ