## エラーか例外か

- 処理が失敗した時にエラーを返却するのか、例外をThrowするのかは、議論に値するテーマである
- エラーを返却する場合
    - 戻り値としてオブジェクトを返却する
    - 結果オブジェクトは開発者に対して強制力を持たない
    - 失敗についてのハンドリングを行うかどうかはクライアントの任意となり、意図せず失敗を見逃すことに繋がる
- 例外をThrowする場合
    - 戻り値を返却しないようになる
    - 何もしなければプログラムが終了する
    - 終了しないようにするにはtry-catch句を記述する必要がある
    - 例外は開発者に対して失敗のハンドリングを強制する
    - 意図せずして後続処理が継続してしまうという事態を防ぐことに繋がる
    - ただ、戻り値のエラーのタイプによって送出されるエラーを表現することができなくなる

## コントローラの責務

- コントローラの責務は入力の変換
- コントローラはユーザからの入力をモデルが要求するメッセージに変換し、モデルに伝えることが責務
- もしコントローラがそれ以上のことをこなしているなら、ドメインの重要な知識やロジックがコントローラに漏れ出している可能性を疑うべき

## データの整合性を保つ方法

- データベースのユニークキー制約
    - データの整合性を守るために積極的に利用すべき
    - ただ、この制約を利用して実装を削るのはやめた方がいい
        - コードの背後（DB）にある制約を読み取ることはできない（ドメインの表現力低下）
        - DBのユニークキー制約という特定の技術基盤に依存しているのも良くない
    - ユニークキー制約はルールを守る主体ではなく、セーフティネットとして活用されるべき機能
- データベースのトランザクション機能を利用する
    - アプリケーションサービスにトランザクションを記述すると、例えば`sqlConnection`というインフラストラクチャのオブジェクトに対する依存がアプリケーションサービスに発生してしまう
    - 回避方法（整合性を保ちながら特定の技術基盤に依存せずに済むパターン）
        - トランザクションを利用する
        - AOPを利用する
        - ユニットオブワークを利用する

## トランザクションが引き起こすロックについて

- DBのトランザクションは一貫性を保証するためにデータをロックする
- トランザクションを利用するにあたり、どれほどロックされるかは常に念頭に置く必要がある
- トランザクションが引き起こすロックは可能な限り小さくすべき
- ロックが広範囲に渡ると、それに比例するように処理が失敗する可能性がある
- ロックを狭める上で大切なのは、一度のトランザクションで保証するオブジェクトを一つに限定し、さらにそのオブジェクトをなるべく小さくすること

## 設計の流れ

1. 要求に従って必要な機能を考える
2. 機能を成り立たせるために必要なユースケースを洗い出す
3. ユースケースを実現するにあたって必要となる概念とそこに存在するルールからアプリケーションが必要とする知識を選び出し、ドメインオブジェクトを準備する
4. ドメインオブジェクトを用いてユースケースを実現するアプリケーションサービスを実装していく

## parser, utils, helperの使い分け

TODO